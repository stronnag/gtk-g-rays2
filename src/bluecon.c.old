#include <glib.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <sys/types.h>
#include <errno.h>
#include <sys/time.h>
#include <unistd.h>
#include "wbt201.h"
#include <gtk/gtk.h>
#include <assert.h>
#include <fcntl.h>

static void  spawn_hcitool(void);
static gboolean try_open_serial(void *);

void reset_quit()
{
    GtkWidget *q;
    assert(NULL != (q=GTK_WIDGET (gtk_builder_get_object
                                  (wbt->builder,
                                   "button3"))));
    gtk_button_set_label (GTK_BUTTON(q),"Exit");
}


static gboolean create_bt_dev(void* unused)
{
    char cmd[256];
    char *p;

    p = (wbt->defrfcom) ? : strdup("/dev/rfcomm0");
    wbt->g->rfcom = strdup(p);
    wbt->curdev = strdup(wbt->g->rfcom);
  
    sprintf(cmd,"sudo rfcomm bind %s %s", wbt->g->rfcom, wbt->g->btaddr);
    int ret = system(cmd);
    if (ret == 0)
    {
        g_idle_add(try_open_serial, NULL);
    }
    return FALSE;
}

static void finalise_hcitool(GPid pid, gint status, gpointer data)

{
    char buf[1024];
    char lbuf[64] = {0};

    FILE *fp = fdopen(wbt->g->sfd, "r");
        
    while(fgets(buf, sizeof(buf), fp) != NULL)
    {
        if(strstr(buf, "G-Rays2"))
        {
            sscanf(buf,"%s",lbuf);
        }
    }
    fclose(fp);
    g_spawn_close_pid(wbt->g->pid);
    wbt->g->pid = 0;
    fprintf(stderr,"Dev %s\n", lbuf);
    if (*lbuf)
    {
        wbt->session_btaddr = strdup(lbuf);
        wbt->g->btaddr = wbt->session_btaddr;
        g_idle_add(create_bt_dev, NULL);
    }
    else
    {
        fprintf(stdout,"Retrying\n");
        spawn_hcitool();
    }
}

void spawn_hcitool(void)
{
    static char * argv[] = {"/usr/bin/hcitool","scan",NULL};
    
    g_spawn_async_with_pipes(NULL,
                             argv,
                             NULL,
                             G_SPAWN_DO_NOT_REAP_CHILD|G_SPAWN_STDERR_TO_DEV_NULL,
                             NULL,
                             &wbt->g,
                             &wbt->g->pid,
                             NULL,
                             &wbt->g->sfd,
                             NULL,
                             NULL);
    g_child_watch_add(wbt->g->pid, finalise_hcitool, &wbt->g);
}

#define BT_MAXTRY 10
#define BT_INCR 20
static gboolean try_open_serial(void *unused)
{
    static guint ntry;

    wbt->serfd = open(wbt->curdev, O_RDWR|O_NOCTTY|O_NONBLOCK|O_NDELAY);
    if (wbt->serfd == -1)
    {
        if (ntry >= BT_MAXTRY)
        {
            ntry = 0;
            wbt_debug("giving up on %s (%s)\n", wbt->curdev, strerror(errno));
            serial_tidy();
            reset_quit_status();
            complete_serial_connect();
        }
        else
        {
            guint to = ntry*BT_INCR;
            ntry += 1;
            g_timeout_add(to, try_open_serial, NULL);
        }
    }
    else
    {
        ntry = 0;
        wbt->sspeed = 57600;
        setup_serial(wbt->serfd, wbt->sspeed);
        reset_quit_status();
        complete_serial_connect();
    }
    return FALSE;
}


void open_bluez_dev(void *unused)
{
    if(wbt->g->btaddr == NULL)
        spawn_hcitool();
    else
        g_idle_add(create_bt_dev, NULL);
}

void g_ray_disconnect(G_rays *g)
{
    if(g->rfcom)
    {
        char cmd[256];
        sprintf(cmd, "sudo rfcomm release %s", g->rfcom);
        system (cmd);
        if(wbt->verbose) wbt_debug("free rfcom\n");        
        g_free (g->rfcom);
        g->rfcom = NULL;
    }
}

G_rays * g_ray_new(void)
{
    G_rays *g = g_malloc0(sizeof(G_rays));
    if(wbt->defrfcom)
    {
        g->rfcom = wbt->defrfcom;
    }
    if(wbt->defbtaddr)
    {
        g->btaddr = wbt->defbtaddr;
    }
    if(wbt->session_btaddr)
    {
        g->btaddr = wbt->session_btaddr;
    }
    return g;
}

int g_ray_connect(G_rays *g)
{
    open_bluez_dev(wbt);
    return 0;
}

